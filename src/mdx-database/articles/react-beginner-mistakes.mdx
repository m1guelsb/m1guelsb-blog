Ao longo de nosso tempo de estudo, percebemos que o React possui uma s√©rie de detalhes que nos pegam desprevenidos e ocasionam comportamentos inesperados ou erros n√£o t√£o detalhados que acabam nos confundindo.

> Dedico este artigo aos iniciantes em React que, assim como o meu eu do passado, perdeu um tempinho tentando resolver tais problemas. üòÖ

<TopicTitle title={"Propriedade style no JSX"}/>
JSX foi constru√≠do para ser bem similar ao cl√°ssico HTML. Mas h√° algumas diferen√ßas que, mesmo bem documentadas, acabamos esquecendo. Dentre essas, h√° o uso de `className` no lugar de `class` e a forma com que atribu√≠mos o valor da propriedade `style`.

No **HTML** atribu√≠mos os valores em uma string e escrevemos parecido com o **CSS** padr√£o:

<CodeHeader title="HTML" />
```html
<button style="height: 3rem; background-color: blue;">
  A really cool button
</button>
```

J√° dentro do JSX, precisamos atribuir em formato de objeto javascript e usando **camelCase** para propriedades que cont√©m nomes compostos.

>Mas h√° uma pegadinha! üßê

Em outras propriedades do JSX, geralmente atribu√≠mos o valor entre **um** par de chaves:
<CodeHeader title="JSX" />
```javascript
return (
  <input placeholder={"My beautiful input"} />
)
```
Por√©m, quando se trata da propriedade `style` precisamos inserir mais um par de chaves para que consigamos atribuir os valores de nossos estilos:
<CodeHeader title="JSX" />
```javascript
return (
  <button style={{ height: "3rem", backgroundColor: "blue" }}>
    A really cool button
  </button>
)
```

Isso acontece porque o primeiro par de chaves serve para criar um **expression slot**, onde podemos atribuir qualquer express√£o javascript como por exemplo um condicional tern√°rio. O segundo par de chaves √© um **objeto javascript** contendo os nossos estilos.

<TopicTitle title={"Acessar um valor que ainda n√£o existe"}/>
Digamos que voc√™ possui um estado que guardar√° dados que ser√£o providos por uma api, ent√£o tentar√° exibir valores da seguinte forma:

<CodeHeader title="/components/PokemonList.jsx" />
```javascript 
import React from 'react';

export const PokemonsList = () => {
  const [pokemons, setPokemons] = React.useState();

  React.useEffect(() => {
    fetch("https://pokeapi.co/api/v2/pokemon")
      .then((response) => response.json())
      .then((data) => setPokemons(data.results));
  }, []);
  
  return (
    <div>
      {pokemons.map((pokemon) => (
        <h2>{pokemon.name}</h2>
      ))}
    </div>
  );
}
```
E ent√£o, vemos o seguinte erro ao tentar iterar `pokemons.map()`:
<CodeHeader title="console" />
```console
  Cannot read properties of undefined (reading 'map')
```

A requisi√ß√£o acontece de forma ass√≠ncrona, ent√£o em primeiro momento, a vari√°vel `pokemons` ir√° conter o valor que atribu√≠mos ao iniciar o estado (que nesse caso deixamos vazio), ou seja: `undefined`.

Temos duas formas de resolver isso:

1. Iniciando o estado como um array vazio:
<CodeHeader title="/components/PokemonList.jsx" />
<CodeChange
  language={"language-javascript"}
  deletion={"const [pokemons, setPokemons] = React.useState();"} 
  addition={"const [pokemons, setPokemons] = React.useState([]);"} />

2. Usando o **optional chaining** `?.`:
<CodeHeader title="/components/PokemonList.jsx" />
<CodeChange
  language={"language-javascript"}
  deletion={"{pokemons.map((pokemon) => ("} 
  addition={"{pokemons?.map((pokemon) => ("} />

Inserir `?.` antes de acessar um m√©todo ou uma propriedade de um objeto que ainda n√£o existe, faz com que o javascript retorne `undefined` em vez de um erro.

>Lembre-se de usar o **optional chaining** sempre que uma propriedade de um objeto pode ser `null` ou `undefined`! ‚òùü§ì

<TopicTitle title={"A propriedade key quando exibindo uma lista"}/>
Muitas vezes ao renderizar uma lista de itens usando `.map`, acabamos esquecendo um detalhe essencial para o React: A propriedade `key`.
<CodeHeader title="console" />
```console
  Warning: Each child in a list should have a unique "key" prop.
```
Quando renderizamos uma lista, precisamos dar um pouco mais de contexto para que o React consiga identificar cada item. E o valor da propriedade `key` deve ser **√∫nico**.
√â comum vemos em alguns lugares o `index` da itera√ß√£o sendo usado:
<CodeHeader title="/components/PokemonList.jsx" />
```javascript
return (
  <div>
    {pokemons.map((pokemon, index) => (
      <!--usando index-->
      <h2 key={index}>{pokemon.name}</h2>
    ))}
  </div>
);
```
>‚ö†Ô∏èMas em alguns casos, isso √© uma m√° ideia.‚ö†Ô∏è

O valor √≠ndex n√£o est√° ligado a cada item espec√≠fico da lista, mas sim a suas posi√ß√µes.

Em uma situa√ß√£o onde a ordem da lista de items mudar√°, o React perde a refer√™ncia de cada um dos itens resultando em problemas de performance, renderiza√ß√£o e at√© acessibilidade.

Para evitar tais problemas devemos atribuir a propriedade `key` um valor realmente √∫nico de cada item. Em nosso caso, onde estamos usando dados de uma api externa, √© esperado que todo item tenha um `id` √∫nico:
<CodeHeader title="/components/PokemonList.jsx" />
```javascript
return (
  <div>
    {pokemons.map((pokemon) => (
      <!--usando id-->
      <h2 key={pokemon.id}>{pokemon.name}</h2>
    ))}
  </div>
);
```
Mas em casos onde tal valor n√£o existe, podemos criar o nosso pr√≥prio `id` √∫nico da seguinte maneira:

<CodeHeader title="/components/PokemonList.jsx" />
```javascript
const pokemonsWithoutId = fetch("/pokemons/noIds")
  .then((response) => response.json())
  .then((data) => return data.results);

//criando uma nova lista
const pokemonsWithId = pokemonsWithoutId.map(item => {
  return {
    ...item,
    //atribuindo um id √∫nico para cada item
    id: crypto.randomUUID(),
  };
});
```
O m√©todo `crypto.randomUUID` √© totalmente seguro de usar, j√° que possui [suporte em todos navegadores atuais.](https://caniuse.com/mdn-api_crypto_randomuuid "Suporte do m√©todo 'crypto.randomUUID'")

Este m√©todo retornar√° um valor parecido com `0bf9b4a4-6bb4-11ee-b962-0242ac120002`, que √© um [universally unique identifier.](https://en.wikipedia.org/wiki/Universally_unique_identifier "Mais sobre UUID")

<TopicTitle title={"Verificando se uma lista est√° vazia"}/>
Digamos que nosso objetivo √© mostrar condicionalmente uma lista somente quando ela n√£o estiver vazia. √â comum pensarmos da seguinte forma:
<CodeHeader title="/components/Pokedex.jsx" />
```jsx
const [pokemons, setPokemons] = React.useState([]);

return (
  <div>
    {pokemons.length && <PokemonList pokemonsData={pokemons} />}
  </div>
);
```
Em nosso HTML veremos um simples **0**. Isso ocorre porque diferente de outros valores [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy "Mais sobre valores falsy") (`""`, `false`, `null`), o n√∫mero **0** √© v√°lido dentro do JSX. Afinal, em algumas ocasi√µes queremos de fato exibi-lo.

Para termos o comportamento esperado podemos fazer uma verifica√ß√£o realmente v√°lida checando se `length` √© maior que 0: `pokemons.length > 0 &&`.\
Ou usar um verificador tern√°rio:
```jsx
return (
  <div>
    {pokemons.length ? (
      <PokemonList pokemonsData={pokemons} />
    ) : null}
  </div>
);
```
E para melhorar a experi√™ncia de uso da nossa aplica√ß√£o, em vez de exibir nada (`null`), poder√≠amos mostrar um feedback de **Loading** para os usu√°rios!

---

Acha que faltou alguma pegadinha que n√£o citei?\
Ficou com alguma d√∫vida?\
Sinta-se livre para me mandar uma mensagem em meu [Twitter/X](https://x.com/m1guelsb).

Obrigado pela leitura! üíï