Tratamento de erros, independente da linguagem, é sempre uma questão complicada. Mas quando se trata de Spring, existe um padrão recomendado e nativo para lidar com exceções sem muita dor de cabeça.

<TopicTitle title={"A situação"}/>
Temos uma aplicação onde estamos usando a biblioteca de validação padrão do Spring:

<CodeHeader title="pom.xml" />
```xml 
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```
E validamos os campos do [DTO](https://www.baeldung.com/java-dto-pattern "O que é DTO?") da entidade `Person`.
<CodeHeader title="PersonDto.java" />
```java
@Data
public class PersonDto {
  @NotBlank(message = "name: Is required")
  @Length(min = 3, max = 100, message = "title: Must be of 3 - 100 characters")
  String name;

  @NotBlank(message = "email: Is required")
  @Email(message = "email: Invalid format")
  String email;

  @NotNull(message = "age: Is required")
  @Min(value = 1, message = "age: Must be greater than 0")
  @Max(value = 100, message = "age: Must be less than 100")
  Integer age;
}
```
Não podemos esquecer a annotation `@Valid` no body do nosso controller:
```java
@PostMapping
public ResponseEntity<Person> create(@RequestBody @Valid @NotNull PersonDto dto) {
  return ResponseEntity.status(HttpStatus.CREATED).body(personService.create(dto));
}
```

<TopicTitle title={"O problema"}/>
Quando enviamos uma requisição com valores inválidos, recebemos algo parecido com isso:
```json
{
  "timestamp": "2023-10-27T00:03:21.577+00:00",
  "status": 400,
  "error": "Bad Request",
  "trace": "org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [0] in public org.springframework.http.ResponseEntity<com.m1guelsb.springexceptions.entities.Person> com.m1guelsb.springexceptions.controllers.PersonController.create(com.m1guelsb.springexceptions.dtos.PersonDto) with 3 errors: [Field error in object 'personDto' on field 'email': rejected value [example]; codes [Email.personDto.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [...]"
}
```

A única informação legível é que o erro que tivemos foi um `400 Bad request`, além disso temos `trace` e `message` com valores nem um pouco descritivos. Não sabemos quais foram os campos incorretos, nem quais valores devem ser enviados.\
Esse tipo de resposta, além de confundir os usuários de nossa API, também expõem as tecnologias que nosso back-end está usando. Podemos considerar isso como uma brecha de segurança já que toda tecnologia contém falhas.

>É importante destacar a parte `MethodArgumentNotValidException` que indica qual o tipo de erro que estamos recebendo. Precisaremos desta informação adiante.

<TopicTitle title={"Filtro global de exceções"}/>
O Spring nos provê um jeito nativo para tratar exceções de modo global, o **Controller Advice**.\
Podemos usá-lo através da annotation `@RestControllerAdvice`.

Para isso é ideal criarmos uma classe onde centralizaremos nossos métodos de tratamento de erro e dentro dela teremos um método que irá nos ajudar a **padronizar** as nossas respostas de erro:
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

  private Map<String, List<String>> errorsMap(List<String> errors) {
    Map<String, List<String>> errorResponse = new HashMap<>();
    errorResponse.put("errors", errors);
    return errorResponse;
  }

}
```
O método `errorsMap` vai receber uma lista de `String` e retornar um `Map` que terá uma única chave `"errors"` com os valores da lista `errors`.\
A representação em JSON é a seguinte:
```JSON
{
  "errors": [
    //lista de erros
  ]
}

```

<TopicTitle title={"Receptando e tratando erros de validação"}/>
Agora finalmente escrevemos o método que irá de fato interceptar os erros e retornar os valores do jeito que queremos:
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(MethodArgumentNotValidException.class)
  public ResponseEntity<Map<String, List<String>>> handleValidationErrors(MethodArgumentNotValidException ex) {

    List<String> errors = ex.getBindingResult()
        .getFieldErrors()
        .stream()
        .map(FieldError::getDefaultMessage)
        .collect(Collectors.toList());

    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorsMap(errors));
  }

  private Map<String, List<String>> errorsMap(List<String> errors) {
    Map<String, List<String>> errorResponse = new HashMap<>();
    errorResponse.put("errors", errors);
    return errorResponse;
  }
}
```
Usando a annotation `@ExceptionHandler()`, nós interceptamos as exceções do tipo `MethodArgumentNotValidException` que é exatamente o mesmo que vimos no `trace` da resposta [anteriormente](#o-problema).

Entendendo o código do método `handleValidationErrors`:
1. Primeiro iteramos em `getFieldErrors()` e coletamos as mensagens padrão com `getDefaultMessage()` e retornamos uma lista de String com elas:
```java 
List<String> errors = ex.getBindingResult()
    .getFieldErrors()
    .stream()
    .map(FieldError::getDefaultMessage)
    .collect(Collectors.toList());
```
2. Então passamos nossa lista de erros para o `errorsMap` retornando dentro do `body` do `ResponseEntity` com o status de `BAD_REQUEST`:
```java 
return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorsMap(errors));
```

Com isso, quando nosso client enviar dados **incorretos**:
```JSON
{
  "name": "Mi",
  "email": "Invalid email",
  "age": 0
}
```

Terá a linda e cheirosa **resposta**:
```JSON
{
  "errors": [
    "title: Must be of 3 - 100 characters",
    "age: Must be greater than 0",
    "email: Invalid format"
  ]
}
```
