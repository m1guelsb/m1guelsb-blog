Tratamento de erros, independente da linguagem, √© sempre uma quest√£o complicada. Mas quando se trata de Spring, existe um padr√£o recomendado e nativo para lidar com exce√ß√µes sem muita dor de cabe√ßa.

>Este tutorial utiliza **Java 17** e **Spring boot 3.1.5**.\
>[C√≥digo completo usado como exemplo](https://github.com/m1guelsb/spring-exceptions). 

<TopicTitle title={"A situa√ß√£o"}/>
Temos uma aplica√ß√£o onde estamos usando a biblioteca de valida√ß√£o padr√£o do Spring:

<h3 title="pom.xml" />
```xml 
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```
E validamos os campos do [DTO](https://www.baeldung.com/java-dto-pattern "O que √© DTO?") da entidade `Person`.
<CodeHeader title="PersonDto.java" />
```java
@Data
public class PersonDto {
  @NotBlank(message = "name: Is required")
  @Length(min = 3, max = 100, message = "title: Must be of 3 - 100 characters")
  String name;

  @NotBlank(message = "email: Is required")
  @Email(message = "email: Invalid format")
  String email;

  @NotNull(message = "age: Is required")
  @Min(value = 1, message = "age: Must be greater than 0")
  @Max(value = 100, message = "age: Must be less than 100")
  Integer age;
}
```
N√£o podemos esquecer a annotation `@Valid` no body do nosso controller:
<CodeHeader title="PersonController.java" />
```java
@PostMapping
public ResponseEntity<Person> create(@RequestBody @Valid @NotNull PersonDto dto) {
  return ResponseEntity.status(HttpStatus.CREATED).body(personService.create(dto));
}
```

<TopicTitle title={"O problema"}/>
Quando enviamos uma requisi√ß√£o para cria√ß√£o de um person com valores inv√°lidos, recebemos algo parecido com isso:

<CodeHeader title="POST REQUEST RESPONSE" />
```json
{
  "timestamp": "2023-10-27T00:03:21.577+00:00",
  "status": 400,
  "error": "Bad Request",
  "trace": "org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [0] in public org.springframework.http.ResponseEntity<com.m1guelsb.springexceptions.entities.Person> com.m1guelsb.springexceptions.controllers.PersonController.create(com.m1guelsb.springexceptions.dtos.PersonDto) with 3 errors: [Field error in object 'personDto' on field 'email': rejected value [example]; codes [Email.personDto.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [...]"
}
```

A √∫nica informa√ß√£o leg√≠vel √© que o erro que foi um `400 Bad request`, al√©m disso temos `trace` e `message` com valores nem um pouco descritivos. N√£o sabemos quais foram os campos incorretos, nem quais valores devem ser enviados.

Isso n√£o apenas confunde o usu√°rio da API, mas tamb√©m exp√µe a tecnologia que o back-end est√° usando. Podemos considerar isso uma brecha de seguran√ßa, pois toda tecnologia cont√©m falhas.

>√â importante destacar a parte `MethodArgumentNotValidException` que indica qual o tipo de erro que estamos recebendo. Precisaremos desta informa√ß√£o adiante.

<TopicTitle title={"Filtro global de exce√ß√µes"}/>
O Spring nos prov√™ um jeito nativo para tratar exce√ß√µes de modo global, o **Controller Advice**.\
Podemos us√°-lo atrav√©s da annotation `@RestControllerAdvice`.

Para isso √© ideal criarmos uma classe onde centralizaremos nossos m√©todos de tratamento de erro e dentro dela teremos um m√©todo que ir√° nos ajudar a **padronizar** as nossas respostas de erro:
<CodeHeader title="GlobalExceptionHandler.java" />
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

  private Map<String, List<String>> errorsMap(List<String> errors) {
    Map<String, List<String>> errorResponse = new HashMap<>();
    errorResponse.put("errors", errors);
    return errorResponse;
  }

}
```
O m√©todo `errorsMap` vai receber uma lista de `String` e retornar um `Map` que ter√° uma √∫nica chave contendo os valores da lista `errors`.\
A representa√ß√£o em JSON √© a seguinte:
```JSON
{
  "errors": [
    //lista de erros
  ]
}
```

<TopicTitle title={"Receptando e tratando erros de valida√ß√£o"}/>
Agora finalmente escrevemos o m√©todo que ir√° de fato interceptar os erros e retornar os valores do jeito que queremos:
<CodeHeader title="GlobalExceptionHandler.java" />
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(MethodArgumentNotValidException.class)
  public ResponseEntity<Map<String, List<String>>> handleValidationErrors(MethodArgumentNotValidException ex) {

    List<String> errors = ex.getBindingResult()
        .getFieldErrors()
        .stream()
        .map(error -> error.getDefaultMessage())
        .toList();

    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorsMap(errors));
  }

  private Map<String, List<String>> errorsMap(List<String> errors) {
    Map<String, List<String>> errorResponse = new HashMap<>();
    errorResponse.put("errors", errors);
    return errorResponse;
  }
}
```
Usando a annotation `@ExceptionHandler()`, n√≥s interceptamos as exce√ß√µes do tipo `MethodArgumentNotValidException` que √© exatamente o mesmo que vimos no `trace` da resposta [anteriormente](#o-problema).

Entendendo o c√≥digo do m√©todo `handleValidationErrors(MethodArgumentNotValidException ex)`:
1. Primeiro iteramos em `getFieldErrors()` ent√£o coletamos as mensagens de erro de `getDefaultMessage()` retornando uma lista com elas:
<CodeHeader title="GlobalExceptionHandler.java" />
```java 
List<String> errors = ex.getBindingResult()
    .getFieldErrors()
    .stream()
    .map(error -> error.getDefaultMessage())
    .toList();
```
2. Ent√£o passamos nossa lista de erros para o `errorsMap` retornando dentro do `body` do `ResponseEntity` com o status de `BAD_REQUEST`:
<CodeHeader title="GlobalExceptionHandler.java" />
```java
return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorsMap(errors));
```

Com isso, quando nosso client enviar dados **incorretos**:
<CodeHeader title="POST REQUEST BODY" />
```JSON
{
  "name": "Mi",
  "email": "Invalid email",
  "age": 0
}
```

Ter√° a linda e cheirosa **resposta**:
<CodeHeader title="POST REQUEST RESPONSE" />
```JSON
{
  "errors": [
    "title: Must be of 3 - 100 characters",
    "age: Must be greater than 0",
    "email: Invalid format"
  ]
}
```
>Meus caros leitores, isso aqui √© o **sonho** de todo dev front-end! ü•∞

<TopicTitle title={"Tratando outros tipos de erro"}/>
Seguindo o mesmo modelo, podemos criar outros m√©todos que lidar√£o com outros tipos de erro.

Outro erro muito comum de acontecer √© o famoso `404 NOT_FOUND`, para trata-lo podemos criar um m√©todo estendendo `RuntimeException` que ir√° nos ajudar a enviar uma mensagem personalizada para cada caso de NOT_FOUND que tivermos:
<CodeHeader title="NotFoundException.java" />
```java
public class NotFoundException extends RuntimeException {
  public NotFoundException(String ex) {
    super(ex);
  }
}
```
E ent√£o, no nosso `GlobalExceptionHandler` adicionamos o seguinte m√©todo:
<CodeHeader title="GlobalExceptionHandler.java" />
```java
@ExceptionHandler(NotFoundException.class)
public ResponseEntity<Map<String, List<String>>> handleNotFoundException(NotFoundException ex) {
  List<String> errors = List.of(ex.getMessage());

  return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorsMap(errors));
}
```
As √∫nicas diferen√ßas do m√©todo do erro anterior √© que trocamos a classe do `ExceptionHandler` para lidar com a nossa classe `NotFoundException`, e o jeito que coletamos a mensagem de erro. Dessa vez criamos uma lista que cont√©m a mensagem de erro retornada com `List.of(ex.getMessage())`.

N√£o podemos esquecer de instanciar e retornar nossa classe sempre que um erro `404` pode ser disparado, como por exemplo o m√©todo `findById` do nosso `PersonService`:
<CodeHeader title="PersonService.java" />
```java
public Person findById(Long id) throws NotFoundException {
  return personRepository.findById(id)
      .orElseThrow(() -> new NotFoundException("Person with id " + id + " not found"));
}
```
Dessa forma, quando nosso client tentar acessar um Person que n√£o existe, ele receber√° a mensagem que inserimos ao instanciar a classe:
<CodeHeader title="404 REQUEST RESPONSE" />
```JSON
{
  "errors": [
    "Person with id 999 not found"
  ]
}
```

E por √∫ltimo mas n√£o menos importante, filtramos tamb√©m os erros de gerais dos tipos `Exception` e `RuntimeException`:
<CodeHeader title="GlobalExceptionHandler.java" />
```java
@ExceptionHandler(Exception.class)
public final ResponseEntity<Map<String, List<String>>> handleGeneralExceptions(Exception ex) {
  List<String> errors = List.of(ex.getMessage());

  return ResponseEntity
      .status(HttpStatus.INTERNAL_SERVER_ERROR)
      .body(errorsMap(errors));
}

@ExceptionHandler(RuntimeException.class)
public final ResponseEntity<Map<String, List<String>>> handleRuntimeExceptions(RuntimeException ex) {
  List<String> errors = List.of(ex.getMessage());

  return ResponseEntity
      .status(HttpStatus.INTERNAL_SERVER_ERROR)
      .body(errorsMap(errors));
}
```

>Seguindo este padr√£o, podemos tratar qualquer tipo de erro e retornar sempre o mesmo padr√£o de mensagens. ü•≥üéâ

---

Por hoje √© isso! ü§ì\
Acha que faltou alguma informa√ß√£o importante ou descobriu algum bug?\
Sinta-se livre para me mandar uma mensagem no [Twitter/X](https://x.com/m1guelsb).

Obrigado pela leitura! üíù